# ðŸ³ Docker Build and Deploy Pipeline
# Advanced containerization and registry management

name: ðŸ³ Docker CI/CD

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      push_to_registry:
        description: 'Push to container registry'
        required: false
        default: true
        type: boolean
      platforms:
        description: 'Target platforms'
        required: false
        default: 'linux/amd64,linux/arm64'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKERFILE_PATH: ./Dockerfile

jobs:
  docker-build:
    name: ðŸ—ï¸ Build Docker Images
    runs-on: ubuntu-latest
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
      image_metadata: ${{ steps.meta.outputs.json }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64,linux/arm64
        driver-opts: |
          network=host
    
    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
        labels: |
          org.opencontainers.image.title=Online Bookstore Flask App
          org.opencontainers.image.description=E-commerce bookstore application with performance monitoring
          org.opencontainers.image.vendor=GitHub Actions
          org.opencontainers.image.licenses=MIT
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ env.DOCKERFILE_PATH }}
        platforms: ${{ github.event.inputs.platforms || 'linux/amd64,linux/arm64' }}
        push: ${{ github.event_name != 'pull_request' && (github.event.inputs.push_to_registry != 'false') }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PYTHON_VERSION=3.11-slim
    
    - name: Generate SBOM (Software Bill of Materials)
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
        format: spdx-json
        output-file: sbom.spdx.json
    
    - name: Upload SBOM
      uses: actions/upload-artifact@v3
      with:
        name: docker-sbom
        path: sbom.spdx.json
        retention-days: 30

  docker-security-scan:
    name: ðŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    needs: docker-build
    if: needs.docker-build.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'docker-security-results.sarif'
    
    - name: Run Trivy for high/critical vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'json'
        output: 'docker-vulnerabilities.json'
        severity: 'HIGH,CRITICAL'
        exit-code: '1'
      continue-on-error: true
    
    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: docker-security-reports
        path: |
          docker-security-results.sarif
          docker-vulnerabilities.json
        retention-days: 30
    
    - name: Upload SARIF to GitHub Security
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: docker-security-results.sarif

  docker-test:
    name: ðŸ§ª Container Testing
    runs-on: ubuntu-latest
    needs: docker-build
    if: needs.docker-build.result == 'success'
    
    strategy:
      matrix:
        platform: [linux/amd64]  # Test on primary platform
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build test image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ env.DOCKERFILE_PATH }}
        platforms: ${{ matrix.platform }}
        load: true
        tags: test-image:latest
        cache-from: type=gha
    
    - name: Test container startup
      run: |
        echo "ðŸš€ Testing container startup..."
        
        # Start container in background
        docker run -d --name test-container -p 5000:5000 test-image:latest
        
        # Wait for container to start
        echo "â³ Waiting for container to start..."
        sleep 30
        
        # Check if container is running
        if docker ps | grep test-container; then
          echo "âœ… Container started successfully"
        else
          echo "âŒ Container failed to start"
          docker logs test-container
          exit 1
        fi
    
    - name: Health check test
      run: |
        echo "ðŸ¥ Testing health endpoint..."
        
        # Test health endpoint
        for i in {1..30}; do
          if curl -f http://localhost:5000/health; then
            echo "âœ… Health check passed"
            break
          fi
          echo "â³ Waiting for health check... ($i/30)"
          sleep 2
        done
        
        # Final health check
        if ! curl -f http://localhost:5000/health; then
          echo "âŒ Health check failed"
          docker logs test-container
          exit 1
        fi
    
    - name: API functionality test
      run: |
        echo "ðŸ” Testing API endpoints..."
        
        # Test main endpoints
        endpoints=("/" "/cart" "/metrics" "/dashboard")
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing $endpoint..."
          if curl -f "http://localhost:5000$endpoint" > /dev/null; then
            echo "âœ… $endpoint working"
          else
            echo "âŒ $endpoint failed"
            exit 1
          fi
        done
    
    - name: Performance baseline test
      run: |
        echo "âš¡ Running performance baseline test..."
        
        # Simple load test
        for i in {1..100}; do
          curl -s http://localhost:5000/ > /dev/null &
        done
        
        # Wait for requests to complete
        wait
        
        # Check metrics
        METRICS=$(curl -s http://localhost:5000/metrics)
        echo "ðŸ“Š Current metrics: $METRICS"
        
        echo "âœ… Performance baseline test completed"
    
    - name: Container resource usage
      run: |
        echo "ðŸ“Š Checking container resource usage..."
        
        # Get container stats
        docker stats test-container --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}\t{{.NetIO}}\t{{.BlockIO}}"
        
        # Check memory usage (should be reasonable)
        MEMORY_USAGE=$(docker stats test-container --no-stream --format "{{.MemUsage}}" | cut -d'/' -f1 | sed 's/[^0-9.]//g')
        echo "Memory usage: ${MEMORY_USAGE}MB"
        
        # Warn if memory usage is too high (>500MB for this simple app)
        if (( $(echo "$MEMORY_USAGE > 500" | bc -l) )); then
          echo "âš ï¸ High memory usage detected: ${MEMORY_USAGE}MB"
        else
          echo "âœ… Memory usage within acceptable range"
        fi
    
    - name: Cleanup test container
      if: always()
      run: |
        docker stop test-container || true
        docker rm test-container || true

  docker-multi-arch-test:
    name: ðŸŒ Multi-Architecture Test
    runs-on: ubuntu-latest
    needs: docker-build
    if: needs.docker-build.result == 'success' && github.event_name != 'pull_request'
    
    strategy:
      matrix:
        platform: 
          - linux/amd64
          - linux/arm64
      fail-fast: false
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Pull and test platform-specific image
      run: |
        echo "ðŸ§ª Testing ${{ matrix.platform }} image..."
        
        # Pull the multi-arch image for specific platform
        docker pull --platform ${{ matrix.platform }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Run basic functionality test
        docker run --rm --platform ${{ matrix.platform }} \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          python -c "
        import sys
        print(f'âœ… Platform: ${{ matrix.platform }}')
        print(f'âœ… Python version: {sys.version}')
        print(f'âœ… Architecture test passed')
        
        # Test basic imports
        try:
            import flask
            import models
            print('âœ… Flask and models import successful')
        except ImportError as e:
            print(f'âŒ Import error: {e}')
            sys.exit(1)
        "
        
        echo "âœ… ${{ matrix.platform }} test completed"

  docker-deploy:
    name: ðŸš€ Deploy Containers
    runs-on: ubuntu-latest
    needs: [docker-build, docker-test, docker-security-scan]
    if: |
      always() && 
      needs.docker-build.result == 'success' && 
      needs.docker-test.result == 'success' && 
      github.ref == 'refs/heads/main'
    
    environment:
      name: container-registry
      url: https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy notification
      run: |
        echo "ðŸš€ Container deployment completed!"
        echo "ðŸ“¦ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        echo "ðŸ·ï¸ Tags: latest, ${{ github.sha }}"
        echo "ðŸŒ Platforms: linux/amd64, linux/arm64"
        
        # Create deployment summary
        cat > deployment-summary.md << EOF
        # ðŸ³ Docker Deployment Summary
        
        **Repository:** ${{ github.repository }}
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        **Actor:** ${{ github.actor }}
        **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ## ðŸ“¦ Container Details
        - **Registry:** ${{ env.REGISTRY }}
        - **Image:** ${{ env.IMAGE_NAME }}
        - **Platforms:** linux/amd64, linux/arm64
        - **Tags:** latest, ${{ github.sha }}, ${{ github.ref_name }}
        
        ## âœ… Quality Checks
        - [x] Build successful
        - [x] Security scan completed
        - [x] Container tests passed
        - [x] Multi-architecture support verified
        
        ## ðŸš€ Usage
        \`\`\`bash
        # Pull and run the container
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        docker run -p 5000:5000 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Access the application
        curl http://localhost:5000/
        \`\`\`
        
        ## ðŸ“Š Container Metadata
        $(echo '${{ needs.docker-build.outputs.image_metadata }}' | jq '.')
        EOF
        
        echo "âœ… Deployment summary created"
    
    - name: Upload deployment summary
      uses: actions/upload-artifact@v3
      with:
        name: docker-deployment-summary
        path: deployment-summary.md
        retention-days: 90